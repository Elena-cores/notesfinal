Cada etapa (stage) es un objeto que empieza con un operador, por ejemplo:


$match ‚Üí filtrar (como un WHERE en SQL).


$group ‚Üí agrupar y calcular agregados (como GROUP BY).


$project ‚Üí seleccionar campos y transformarlos (como SELECT columna AS ...).


$sort ‚Üí ordenar.


$limit ‚Üí limitar resultados.

üìä Ejemplo pr√°ctico


Supongamos que tienes una colecci√≥n ventas con documentos as√≠

{ "producto": "camiseta", "precio": 20, "cantidad": 2, "tienda": "Madrid" }
{ "producto": "camiseta", "precio": 20, "cantidad": 1, "tienda": "Barcelona" }
{ "producto": "pantal√≥n", "precio": 40, "cantidad": 1, "tienda": "Madrid" }



Ejemplo de aggregate


Queremos: total vendido por producto.

db.ventas.aggregate([
  {
    $group: {
      _id: "$producto",                 // Agrupamos por producto
      totalVendido: { $sum: { $multiply: ["$precio", "$cantidad"] } }, // suma de precio*cantidad
      totalUnidades: { $sum: "$cantidad" } // suma de unidades
    }
  }
])



Resultado esperado



[
  { "_id": "camiseta", "totalVendido": 60, "totalUnidades": 3 },
  { "_id": "pantal√≥n", "totalVendido": 40, "totalUnidades": 1 }
]


üîó Ejemplo con m√°s etapas


Si ahora queremos solo productos con m√°s de 50‚Ç¨ en ventas, y ordenados de mayor a menor:



db.ventas.aggregate([
  {
    $group: {
      _id: "$producto",
      totalVendido: { $sum: { $multiply: ["$precio", "$cantidad"] } }
    }
  },
  { $match: { totalVendido: { $gt: 50 } } }, // filtrar
  { $sort: { totalVendido: -1 } }            // ordenar descendente
])



aggregate = lista de etapas (pipeline).






Supongamos que la colecci√≥n zip guarda documentos de c√≥digos postales en EE.UU. (es un dataset de ejemplo que suele venir con MongoDB), con una estructura como esta:



{
  "_id": "10001",
  "city": "NEW YORK",
  "state": "NY",
  "pop": 21102
}



Aqu√≠:



_id = c√≥digo postal

city = ciudad


state = estado


pop = poblaci√≥n de ese c√≥digo postal



üîπ Ejemplo 1: poblaci√≥n total por estado



db.zip.aggregate([
  {
    $group: {
      _id: "$state",         // Agrupamos por estado
      totalPoblacion: { $sum: "$pop" }, // sumamos la poblaci√≥n de todos los c√≥digos postales
      numCiudades: { $sum: 1 }          // contamos cu√°ntos ZIP hay en ese estado
    }
  }
])



üìå Esto te devuelve algo as√≠:



{ "_id": "NY", "totalPoblacion": 17990402, "numCiudades": 1590 }
{ "_id": "CA", "totalPoblacion": 29754890, "numCiudades": 1523 }




üîπ Ejemplo 2: estados con m√°s de 10 millones de habitantes



db.zip.aggregate([
  {
    $group: {
      _id: "$state",
      totalPoblacion: { $sum: "$pop" }
    }
  },
  { $match: { totalPoblacion: { $gt: 10000000 } } }, // solo estados con >10M habitantes
  { $sort: { totalPoblacion: -1 } } // ordenamos de mayor a menor
])



Resultado esperado:



{ "_id": "CA", "totalPoblacion": 29754890 }
{ "_id": "NY", "totalPoblacion": 17990402 }




üîπ Ejemplo 3: poblaci√≥n media por ciudad dentro de cada estado



db.zip.aggregate([
  {
    $group: {
      _id: { state: "$state", city: "$city" }, // agrupamos por estado + ciudad
      poblacionCiudad: { $sum: "$pop" }        // sumamos poblaci√≥n de todos sus ZIP
    }
  },
  {
    $group: {
      _id: "$_id.state",                        // reagrupamos por estado
      poblacionMediaCiudades: { $avg: "$poblacionCiudad" } // sacamos la media
    }
  },
  { $sort: { poblacionMediaCiudades: -1 } }
])



Esto te da, por ejemplo:



{ "_id": "CA", "poblacionMediaCiudades": 85000 }
{ "_id": "TX", "poblacionMediaCiudades": 62000 }












// index.js
const http = require('http');
const { randomInt } = require('crypto');
const port = 3000;

// Diccionario de ejemplo (c√°mbialo por el tuyo o carga desde un archivo)
const DICTIONARY = [
  'sol', 'luna', 'mar', 'tierra', 'fuego', 'nube', 'rio', 'viento', 'roca', 'bosque',
  'rojo', 'verde', 'azul', 'negro', 'blanco', 'oro', 'plata', 'bronce', 'claro', 'oscuro',
  'gato', 'perro', 'zorro', 'delfin', 'tigre', 'panda', 'loro', '√°guila', 'koala', 'ballena',
  'cafe', 'te', 'pan', 'queso', 'miel', 'sal', 'azucar', 'limon', 'nuez', 'maiz',
  'laser', 'pixel', 'nube2', 'byte', 'bit', 'token', 'server', 'client', 'router', 'cache'
];

// Utilidad: elige n palabras aleatorias del diccionario
function pickWords(n, dict = DICTIONARY) {
  const out = [];
  for (let i = 0; i < n; i++) {
    const idx = randomInt(0, dict.length);
    out.push(dict[idx]);
  }
  return out;
}

// Render de la p√°gina HTML
function renderPage(password, x) {
  return `<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Generador de contrase√±a (${x} palabras)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 40px; }
    .pw { font-size: 1.6rem; font-weight: 700; letter-spacing: .5px; padding: .6rem 1rem; border: 1px solid #ddd; border-radius: 8px; display: inline-block; }
    .hint { color: #555; margin-top: .5rem; }
    .links a { margin-right: .75rem; }
  </style>
</head>
<body>
  <h1>Contrase√±a aleatoria</h1>
  <p class="pw">${password}</p>
  <p class="hint">Cambiar n√∫mero de palabras con el par√°metro <code>?x=</code>.</p>
  <div class="links">
    <strong>Ejemplos:</strong>
    <a href="/?x=3">x=3</a>
    <a href="/?x=4">x=4</a>
    <a href="/?x=6">x=6</a>
  </div>
</body>
</html>`;
}

const server = http.createServer((req, res) => {
  // Parseo de la URL con base para poder usar URLSearchParams
  const url = new URL(req.url, `http://${req.headers.host}`);

  // Solo la ruta principal; podr√≠as a√±adir 404 para otras rutas si quieres
  if (url.pathname !== '/') {
    res.statusCode = 404;
    res.setHeader('Content-Type', 'text/plain; charset=utf-8');
    return res.end('404 No encontrado');
  }

  // Lee x desde la query (?x=5). Valor por defecto 4.
  let x = parseInt(url.searchParams.get('x') ?? '4', 10);

  // Validaciones y l√≠mites razonables
  if (Number.isNaN(x) || x <= 0) x = 4;                 // por defecto
  if (x > 20) x = 20;                                   // evita x enormes
  if (x > DICTIONARY.length) x = DICTIONARY.length;     // no m√°s que el diccionario

  // Genera la contrase√±a uniendo palabras con guiones (puedes usar espacios u otro separador)
  const words = pickWords(x);
  const password = words.join('-');

  // Respuesta HTML
  res.statusCode = 200;
  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  res.end(renderPage(password, x));
});

server.listen(port, () => {
  console.log(`server is running on http://localhost:${port}`);
});  --// reemplaza : // reemplaza el DICTIONARY de arriba por esto:
const fs = require('fs');
const DICTIONARY = fs.readFileSync('./diccionario.txt', 'utf8')
  .split(/\r?\n/)
  .map(w => w.trim())
  .filter(Boolean);

